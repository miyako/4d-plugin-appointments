/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Appointments.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Appointments
 #	author : miyako
 #	2020/09/06
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Appointments.h"

bool request_permission_granted_for_events = false;

request_permission_t requestPermission(){
    
    if (@available(macOS 10.9, *)) {
    
        switch ([EKEventStore authorizationStatusForEntityType:EKEntityTypeEvent])
        {
            case EKAuthorizationStatusNotDetermined:
            {
                EKEventStore *store = [EKEventStore new];
                [store requestAccessToEntityType:EKEntityTypeEvent completion:^(BOOL granted, NSError * _Nullable error) {
                    if (granted) {
                        request_permission_granted_for_events = true;
                    }
                }];
                return request_permission_not_determined;
                break;
            }
            break;
            case EKAuthorizationStatusRestricted:
                request_permission_granted_for_events = false;
            return request_permission_restricted;
            break;
            case EKAuthorizationStatusDenied:
                request_permission_granted_for_events = false;
            return request_permission_denied;
            break;
            case EKAuthorizationStatusAuthorized:
                request_permission_granted_for_events = true;
                break;
            return request_permission_authorized;
            break;
        }
    }
    return request_permission_unknown;
}

namespace DateFormatter
{
    NSDateFormatter *ISO;
    NSDateFormatter *GMT;
}

namespace CalendarWatch
{
    
    class UserInfo
    {
    private:
        
        notification_t _notification;
        CUTF8String _uid;
        method_id_t _method;
        
    public:
        
        UserInfo(notification_t notification, NSString *event_uid, method_id_t method);
        
        void get(notification_t *notification, CUTF16String &event, method_id_t *method);
        
        ~UserInfo();
    };
    
    UserInfo::UserInfo(notification_t notification, NSString *event_uid, method_id_t method)
    {
        this->_notification = notification;
        if(event_uid)
        {
            this->_uid = CUTF8String((const uint8_t *)[event_uid UTF8String]);
        }
        this->_method = method;
    }
    
    void UserInfo::get(notification_t *notification, CUTF16String &event, method_id_t *method)
    {
        *notification = this->_notification;
        
        *method = this->_method;
        
        C_TEXT t;
        t.setUTF8String(&this->_uid);
        t.copyUTF16String(&event);
    }
    
    UserInfo::~UserInfo()
    {
        
    }
    
    const process_stack_size_t stachSize = 0;
    const process_name_t processName = (PA_Unichar *)"$\0C\0A\0L\0E\0N\0D\0A\0R\0_\0W\0A\0T\0C\0H\0\0\0";
    
    std::map<CUTF8String, method_id_t> paths;
    std::vector<UserInfo> notifications;
    
    FSEventStreamRef eventStream = 0;
    NSTimeInterval latency = 1.0;
    process_number_t monitorProcessId = 0;
    bool processShouldTerminate = false;
    
    method_id_t getMethodId(NSString *path_ns)
    {
        @autoreleasepool
        {
            NSString *monitorPath_ns = [path_ns stringByDeletingLastPathComponent];
            CUTF8String monitorPath = CUTF8String((const uint8_t *)[monitorPath_ns UTF8String]);
            monitorPath += (const uint8_t *)"/";
            //global variables: CalendarWatch::paths
            NSLock *l = [[NSLock alloc]init];
            if ([l tryLock])
            {
                auto i = paths.find(monitorPath);
                if (i != paths.end())
                {
                    return i->second;
                }
                [l unlock];
            }
            [l release];
        }
        return 0;
    }
    
    void gotEvent(FSEventStreamRef stream,
                                void *callbackInfo,
                                size_t numEvents,
                                void *eventPaths,
                                const FSEventStreamEventFlags eventFlags[],
                                const FSEventStreamEventId eventIds[]
                                )
    {
        //global variables: CalendarWatch::notifications
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            @autoreleasepool
            {
                NSArray *paths_ns = (NSArray *)eventPaths;
                NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"([:HexDigit:]{8}-[:HexDigit:]{4}-[:HexDigit:]{4}-[:HexDigit:]{4}-[:HexDigit:]{12})\\.ics$"
                                                                                                                                                             options:NSRegularExpressionCaseInsensitive
                                                                                                                                                                 error:nil];
                if(regex)
                {
                    for(NSUInteger i = 0; i < numEvents; ++i)
                    {
                        NSString *path_ns = [paths_ns objectAtIndex:i];
                        
                        NSArray *matches = [regex matchesInString:path_ns
                                                                                            options:0
                                                                                                range:NSMakeRange(0, [path_ns length])];
                        
                        for (NSTextCheckingResult *match in matches)
                        {
                            NSString *event_uid = [path_ns substringWithRange:[match rangeAtIndex:1]];
                            FSEventStreamEventFlags flags = eventFlags[i];
                            method_id_t methodId = getMethodId(path_ns);
//                            NSLog(@"flags:%d", (unsigned int)flags);
                            if(methodId)
                            {
                                if((flags & kFSEventStreamEventFlagItemRemoved) == kFSEventStreamEventFlagItemRemoved)
                                {
//                                    NSLog(@"removed calendar item:\t%@", event_uid);
                                    UserInfo userInfo(notification_delete, event_uid, methodId);
                                    notifications.push_back(userInfo);
                                }
                                else if((flags & kFSEventStreamEventFlagItemCreated) == kFSEventStreamEventFlagItemCreated)
                                {
//                                    NSLog(@"created calendar item:\t%@", event_uid);
                                    UserInfo userInfo(notification_create, event_uid, methodId);
                                    notifications.push_back(userInfo);
                                }
                                else
                                {
//                                    NSLog(@"modified calendar item:\t%@", event_uid);
                                    UserInfo userInfo(notification_update, event_uid, methodId);
                                    notifications.push_back(userInfo);
                                }
                            }
                        }
                    }
                }
            }//@autoreleasepool
            listenerLoopExecute();
            [l unlock];
        }
        [l release];
    }
    
    void endMonitor()
    {
        //global variables: CalendarWatch::eventStream
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            if(eventStream)
            {
                FSEventStreamStop(eventStream);
                FSEventStreamUnscheduleFromRunLoop (eventStream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
                FSEventStreamInvalidate(eventStream);
                FSEventStreamRelease(eventStream);
                eventStream = 0;
//                NSLog(@"stop monitoring paths");
            }
            [l unlock];
        }
        [l release];
    }
    
    void startMonitor()
    {
        FSEventStreamContext context = {0, NULL, NULL, NULL, NULL};
        
        NSMutableArray *paths_ns = [[NSMutableArray alloc]init];
        //global variables: CalendarWatch::paths
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            for(std::map<CUTF8String, method_id_t>::iterator it = CalendarWatch::paths.begin(); it != CalendarWatch::paths.end(); it++)
            {
                CUTF8String path = it->first;
                NSString *path_ns = [[NSString alloc]initWithUTF8String:(const char *)path.c_str()];
                if(path_ns)
                {
                    [paths_ns addObject:path_ns];
                    [path_ns release];
                }
            }
            [l unlock];
        }
        
        endMonitor();
        
        listenerLoopStart();
        
        if([paths_ns count])
        {
            if ([l tryLock])
            {
                eventStream = FSEventStreamCreate(NULL,
                                                                                    (FSEventStreamCallback)gotEvent,
                                                                                    &context,
                                                                                    (CFArrayRef)paths_ns,
                                                                                    kFSEventStreamEventIdSinceNow,
                                                                                    (CFAbsoluteTime)latency,
                                                                                    kFSEventStreamCreateFlagUseCFTypes
                                                                                    | kFSEventStreamCreateFlagFileEvents
                                                                                    | kFSEventStreamCreateFlagNoDefer
                                                                                    | kFSEventStreamCreateFlagIgnoreSelf
                                                                                    );
//                NSLog(@"start monitoring paths:%@", [paths_ns description]);
                FSEventStreamScheduleWithRunLoop(eventStream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
                FSEventStreamStart(eventStream);
                
                [l unlock];
            }
            [l release];
            
        }
        [paths_ns release];
    }
    
    bool isInWatch(CUTF8String &path)
    {
        bool inWatch = false;
        
        NSLock *l = [[NSLock alloc]init];
        
        if ([l tryLock])
        {
            auto i = paths.find(path);
            inWatch = (i != paths.end());
            [l unlock];
        }
        
        [l release];
        
        return inWatch;
    }
    
    void addToWatch(CUTF8String &path, method_id_t methodId)
    {
        if (!isInWatch(path))
        {
            NSLock *l = [[NSLock alloc]init];
            if ([l tryLock])
            {
                paths.insert(std::map<CUTF8String, method_id_t>::value_type(path, methodId));
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)startMonitor, NULL);
                [l unlock];
            }
            [l release];
        }
    }
    
    void removeFromWatch(CUTF8String &path)
    {
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            paths.erase(path);
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)startMonitor, NULL);
            if(!paths.size())
            {
                listenerLoopFinish();
            }
            [l unlock];
        }
        [l release];
    }
    
    void removeAllFromWatch()
    {
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            paths.clear();
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)endMonitor, NULL);
            listenerLoopFinish();
            [l unlock];
        }
        [l release];
    }
    
}

void onStartup()
{
    DateFormatter::GMT = [[NSDateFormatter alloc]init];
    [DateFormatter::GMT setDateFormat:DATE_FORMAT_ISO_GMT];
    [DateFormatter::GMT setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
    
    DateFormatter::ISO = [[NSDateFormatter alloc]init];
    [DateFormatter::ISO setDateFormat:DATE_FORMAT_ISO];
    [DateFormatter::ISO setTimeZone:[NSTimeZone localTimeZone]];
    
    requestPermission();
}

bool isProcessOnExit()
{
    PA_long32 state, time;
    
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    PA_Variable name = PA_GetProcessInfo_s(currentProcessNumber, &state, &time);
    PA_Unistring u = PA_GetStringVariable(name);
    CUTF16String procName(u.fString, u.fLength);
    PA_Unichar _exitProcName[] = {'$', 'x', 'x', 0};
    CUTF16String exitProcName((PA_Unichar *)_exitProcName);
    bool isProcessOnExit = (!procName.compare(exitProcName));
    PA_ClearVariable(&name);
    
    return isProcessOnExit;
}

void onCloseProcess()
{
    if(isProcessOnExit())
    {
        CalendarWatch::removeAllFromWatch();
        [DateFormatter::GMT release];
        [DateFormatter::ISO release];
    }
}

const char *sql_get_calendar_group_uid = "SELECT\n\
ZUID\n\
FROM ZNODE\n\
WHERE Z_PK ==\n\
(\n\
SELECT ZGROUP\n\
FROM  ZNODE\n\
WHERE ZUID == ?\n\
LIMIT 1\n\
);";

const char *sql_get_calendars = "SELECT\n\
ZUID, ZTITLE\n\
FROM ZNODE\n\
WHERE ZISTASKCONTAINER != 1\n\
AND ZGROUP != '';";

void sqlite3_get_calendar_group_uid(NSString *userCalendarPath,
                                                                        CUTF8String &calendar_uid,
                                                                        CUTF8String &group_uid)
{
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        sqlite3 *sqlite3_calendar = NULL;
        
        int err = sqlite3_open([userCalendarPath UTF8String], &sqlite3_calendar);
        
        if(err != SQLITE_OK)
        {
//            NSLog(@"failed to open sqlite database at:%@", userCalendarPath);
        }else
        {
            sqlite3_stmt *sql = NULL;
            err = sqlite3_prepare_v2(sqlite3_calendar, sql_get_calendar_group_uid, 1024, &sql, NULL);
            if(err != SQLITE_OK)
            {
//                NSLog(@"failed to prepare sqlite statement");
            }else
            {
                sqlite3_bind_text(sql, 1, (const char *)calendar_uid.c_str(), calendar_uid.length(), NULL);
                
                while(SQLITE_ROW == (err = sqlite3_step(sql)))
                {
                    const unsigned char *_group_uid = sqlite3_column_text(sql, 0);
                    if(_group_uid)
                    {
                        group_uid = CUTF8String(_group_uid, strlen((const char *)_group_uid));
                    }
                }
                sqlite3_finalize(sql);
            }
            sqlite3_close(sqlite3_calendar);
        }
        [l unlock];
    }
    [l release];
}

void sqlite3_get_calendars(NSString *userCalendarPath,
                                                     ARRAY_TEXT &uids,
                                                     ARRAY_TEXT &titles)
{
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        sqlite3 *sqlite3_calendar = NULL;
        
        int err = sqlite3_open([userCalendarPath UTF8String], &sqlite3_calendar);
        
        if(err != SQLITE_OK)
        {
//            NSLog(@"failed to open sqlite database at:%@", userCalendarPath);
        }else
        {
            sqlite3_stmt *sql = NULL;
            err = sqlite3_prepare_v2(sqlite3_calendar, sql_get_calendars, 1024, &sql, NULL);
            if(err != SQLITE_OK)
            {
//                NSLog(@"failed to prepare sqlite statement");
            }else
            {
                while(SQLITE_ROW == (err = sqlite3_step(sql)))
                {
                    const unsigned char *_calendar_uid = sqlite3_column_text(sql, 0);
                    const unsigned char *_title = sqlite3_column_text(sql, 1);
                    
                    if(_calendar_uid)
                    {
                        if(_title)
                        {
                            uids.appendUTF8String(_calendar_uid, strlen((const char *)_calendar_uid));
                            titles.appendUTF8String(_title, strlen((const char *)_title));
                        }
                        
                    }
                }
                sqlite3_finalize(sql);
            }
            sqlite3_close(sqlite3_calendar);
        }
        [l unlock];
    }
    [l release];
}

#pragma mark -

void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
    CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
    NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
    returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

#pragma mark -

void listenerLoop()
{
    CalendarWatch::monitorProcessId = PA_GetCurrentProcessNumber();
//    NSLog(@"%@", @"listenerLoop:start");
    
    NSLock *l = [[NSLock alloc]init];
    
    while((!CalendarWatch::processShouldTerminate) && !PA_IsProcessDying())
    {
        PA_FreezeProcess(PA_GetCurrentProcessNumber());
        PA_YieldAbsolute();
        
        //global variables: CalendarWatch::notifications,processShouldTerminate
        if ([l tryLock])
        {
            if(!CalendarWatch::processShouldTerminate)
            {
                if(CalendarWatch::notifications.size())
                {
                    C_TEXT processName;
                    generateUuid(processName);
                    PA_NewProcess((void *)listenerLoopExecuteMethod,
                                                CalendarWatch::stachSize,
                                                (PA_Unichar *)processName.getUTF16StringPtr());
                }
            }
            [l unlock];
        }
    }//while(!CalendarWatch::processShouldTerminate)
    CalendarWatch::monitorProcessId = 0;
    
    PA_KillProcess();
//    NSLog(@"%@", @"listenerLoop:end");
    [l release];
}

void listenerLoopStart()
{
    //global variables: CalendarWatch::monitorProcessId,processShouldTerminate
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        if(!CalendarWatch::monitorProcessId)
        {
            CalendarWatch::processShouldTerminate = false;
            PA_NewProcess((void *)listenerLoop,
                                        CalendarWatch::stachSize,
                                        CalendarWatch::processName);
        }
        [l unlock];
    }
    [l release];
}

void listenerLoopFinish()
{
    //global variables: CalendarWatch::monitorProcessId,processShouldTerminate
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        CalendarWatch::processShouldTerminate = true;
        PA_UnfreezeProcess(CalendarWatch::monitorProcessId);
        [l unlock];
    }
    [l release];
}

void listenerLoopExecute()
{
    //global variables: CalendarWatch::monitorProcessId,processShouldTerminate
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        CalendarWatch::processShouldTerminate = false;
        PA_UnfreezeProcess(CalendarWatch::monitorProcessId);
        [l unlock];
    }
    [l release];
}

#pragma mark CalendarStore

EKEventStore *json_get_calendar_store(Json::Value& obj)
{
    EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
    
    if(obj)
    {
        obj["json_get_calendar_store"] = (defaultCalendarStore ? "OK" : "calendar access denied");
    }
    return defaultCalendarStore;
}

EKCalendar *json_get_calendar(Json::Value& obj, C_TEXT& Param1)
{
    EKCalendar *calendar = nil;
   
    EKEventStore *defaultCalendarStore = json_get_calendar_store(obj);
    
    if(defaultCalendarStore)
    {
        NSString *calendarName = Param1.copyUTF16String();
        NSArray *calendars = [defaultCalendarStore calendarsForEntityType:EKEntityTypeEvent];
        for(NSUInteger i = 0; i < [calendars count]; ++i)
        {
            EKCalendar *c = [calendars objectAtIndex:i];
            
            if(([[c title]caseInsensitiveCompare:calendarName] == NSOrderedSame)
               && c.type == EKCalendarTypeCalDAV)
            {
                calendar = c;
                break;
            }
        }
    }
    
    if(obj)
    {
        obj["json_get_calendar"] = (calendar ? "OK" : "calendar not found");
    }
    
    return calendar;
}

EKEvent *json_get_event(Json::Value& obj, C_TEXT& Param1)
{
    EKEvent *event = nil;
    
    EKEventStore *defaultCalendarStore = json_get_calendar_store(obj);
    
    if(defaultCalendarStore)
    {
        NSString *uid = Param1.copyUTF16String();
        
        NSArray *events = [defaultCalendarStore calendarItemsWithExternalIdentifier:uid];
        if([events count]) {
            event = [events objectAtIndex:0];
        }
                
        [uid release];
        
        [defaultCalendarStore release];
    }
    
    if(obj)
    {
        obj["json_get_event"] = (event ? "OK" : "event not found");
    }
    
    return event;
}

void json_set_event(Json::Value& obj, EKEvent *event)
{
    
    obj["location"] = event.location ? [event.location UTF8String] : Json::Value(Json::nullValue);
    obj["notes"] = event.notes ? [event.notes UTF8String] : Json::Value(Json::nullValue);
    obj["title"] = event.title ? [event.title UTF8String] : Json::Value(Json::nullValue);
    obj["url"] = event.URL ? [[event.URL absoluteString]UTF8String] : Json::Value(Json::nullValue);
    obj["uid"] = event.calendarItemExternalIdentifier ? [event.calendarItemExternalIdentifier UTF8String] : Json::Value(Json::nullValue);

    obj["endDate"] = event.endDate ? [[DateFormatter::GMT stringFromDate:event.endDate]UTF8String] : Json::Value(Json::nullValue);
    
    obj["startDate"] = event.startDate ? [[DateFormatter::GMT stringFromDate:event.startDate ]UTF8String] : Json::Value(Json::nullValue);
    
    
    obj["dateStamp"] = event.lastModifiedDate ? [[DateFormatter::GMT stringFromDate:event.lastModifiedDate]UTF8String] : Json::Value(Json::nullValue);

    if(event.endDate){
        
        NSString *localDateString = [DateFormatter::ISO stringFromDate:event.endDate];
        int hour = (int)[[localDateString substringWithRange:NSMakeRange(11,2)]integerValue];
        int minute = (int)[[localDateString substringWithRange:NSMakeRange(14,2)]integerValue];
        int second = (int)[[localDateString substringWithRange:NSMakeRange(17,2)]integerValue];
        obj["endDateTime"] = (second + (minute * 60) + (hour * 3600)) * 1000;

    }
    
    if(event.startDate){
        
        NSString *localDateString = [DateFormatter::ISO stringFromDate:event.startDate];
        int hour = (int)[[localDateString substringWithRange:NSMakeRange(11,2)]integerValue];
        int minute = (int)[[localDateString substringWithRange:NSMakeRange(14,2)]integerValue];
        int second = (int)[[localDateString substringWithRange:NSMakeRange(17,2)]integerValue];
        obj["startDateTime"] = (second + (minute * 60) + (hour * 3600)) * 1000;

    }
    
    if(event.lastModifiedDate){
        
        NSString *localDateString = [DateFormatter::ISO stringFromDate:event.lastModifiedDate];
        
        int hour = (int)[[localDateString substringWithRange:NSMakeRange(11,2)]integerValue];
        int minute = (int)[[localDateString substringWithRange:NSMakeRange(14,2)]integerValue];
        int second = (int)[[localDateString substringWithRange:NSMakeRange(17,2)]integerValue];
        obj["dateStampTime"] = (second + (minute * 60) + (hour * 3600)) * 1000;

    }
        
    obj["calendarName"] = [event.calendar.title UTF8String];

    if(([event startDate]) && ([event endDate]))
    {
        obj["duration"] = [[event endDate] timeIntervalSinceDate:[event startDate]];
    }
    
}

bool json_get_calendarPath(C_TEXT &Param1, CUTF8String &path)
{
    bool success = NO;
    
    NSString *userCalendarPath = [NSString stringWithFormat:@"%@/Calendars/",
                                                                [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)
                                                                 objectAtIndex:0]];
    ARRAY_TEXT out_uids;
    ARRAY_TEXT out_titles;
    
    NSString *titleToSearch = Param1.copyUTF16String();
    
    sqlite3_get_calendars([NSString stringWithFormat:@"%@Calendar Cache", userCalendarPath], out_uids, out_titles);
    
    NSUInteger size = out_uids.getSize();
    
    for(NSUInteger i = 0; i < size; ++i)
    {
        NSString *title = out_titles.copyUTF16StringAtIndex(i);
        
        if([title isEqualToString:titleToSearch])
        {
            CUTF8String calendar_uid, group_uid;
            out_uids.copyUTF8StringAtIndex(&calendar_uid, i);
            
            sqlite3_get_calendar_group_uid([NSString stringWithFormat:@"%@Calendar Cache", userCalendarPath], calendar_uid, group_uid);
            
            NSFileManager *defaultManager = [[NSFileManager alloc]init];
            
            NSString *path_caldav = [NSString stringWithFormat:@"%@%s%s/%s%s", userCalendarPath, group_uid.c_str(), ".caldav", calendar_uid.c_str(), ".calendar"];
            NSString *path_exchange = [NSString stringWithFormat:@"%@%s%s/%s%s", userCalendarPath, group_uid.c_str(), ".exchange", calendar_uid.c_str(), ".calendar"];
            
            BOOL isDirectory;
            C_TEXT temp;
            
            if(([defaultManager fileExistsAtPath:path_caldav isDirectory:&isDirectory]) && isDirectory)
            {
                temp.setUTF16String([NSString stringWithFormat:@"%@/Events/", path_caldav]);
                temp.copyUTF8String(&path);
                success = YES;
            }
            else if(([defaultManager fileExistsAtPath:path_exchange isDirectory:&isDirectory]) && isDirectory)
            {
                temp.setUTF16String([NSString stringWithFormat:@"%@/Events/", path_exchange]);
                temp.copyUTF8String(&path);
                success = YES;
            }
            [defaultManager release];
        }
        
        [title release];
        
        if(success) break;
    }
    
    [titleToSearch release];
    
    return success;
}

void event_to_json(CUTF16String *eventId, CUTF16String *eventJson)
{
    
    Json::Value r = Json::Value(Json::objectValue);

    C_TEXT Param1;
    Param1.setUTF16String(eventId);
    
    EKEvent *event = json_get_event(r, Param1);
    
    if(event)
    {
        Json::Value ee = Json::Value(Json::arrayValue);
        Json::Value e = Json::Value(Json::objectValue);
        
        json_set_event(e, event);
        
        ee.append(e);
        
        Json::StreamWriterBuilder writer;
        writer["indentation"] = "";
        
        C_TEXT t;
        std::string json = Json::writeString(writer, ee);
        t.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());
        
        t.copyUTF16String(eventJson);
    }
    
}

void listenerLoopExecuteMethod()
{
    //global variables: CalendarWatch::notifications
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        if(CalendarWatch::notifications.size())
        {
            std::vector<CalendarWatch::UserInfo>::iterator it = CalendarWatch::notifications.begin();
            
            CalendarWatch::UserInfo userInfo = *it;
            
            notification_t notification;
            CUTF16String eventId;
            method_id_t methodId;
            
            userInfo.get(&notification, eventId, &methodId);
            
            PA_Variable    params[3];

            params[0] = PA_CreateVariable(eVK_Longint);
            params[1] = PA_CreateVariable(eVK_Unistring);
            params[2] = PA_CreateVariable(eVK_Unistring);

            PA_SetLongintVariable(&params[0], notification);
            
            PA_Unistring event = PA_CreateUnistring((PA_Unichar *)eventId.c_str());
            PA_SetStringVariable(&params[1], &event);

            //eventId to JSON
            CUTF16String eventJson;
            event_to_json(&eventId, &eventJson);
            PA_Unistring eventInfo = PA_CreateUnistring((PA_Unichar *)eventJson.c_str());
            PA_SetStringVariable(&params[2], &eventInfo);
            
            CalendarWatch::notifications.erase(it);
            
            PA_ExecuteMethodByID(methodId, params, 3);
            
            PA_ClearVariable(&params[0]);
            PA_ClearVariable(&params[1]);
            PA_ClearVariable(&params[2]);
        }
        [l unlock];
    }
    [l release];
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
                case kInitPlugin :
                case kServerInitPlugin :
                    onStartup();
                    break;
                    
                case kCloseProcess :
                    onCloseProcess();
                    break;
                
			// --- Appointments
            
			case 1 :
				ALL_APPOINTMENTS(params);
				break;
			case 2 :
				Get_appointment(params);
				break;
			case 3 :
				UPDATE_APPOINTMENT(params);
				break;
			case 4 :
				DELETE_APPOINTMENT(params);
				break;
			case 5 :
				ON_APPOINTMENT_CALL(params);
				break;
			case 6 :
				CREATE_APPOINTMENT(params);
				break;
			case 7 :
				APPOINTMENT_NAMES(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void ALL_APPOINTMENTS(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    Json::Value ee = Json::Value(Json::arrayValue);
    
    //no err object
    
    EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
    
    if(defaultCalendarStore)
    {
        Json::Value r = Json::Value(Json::objectValue);
        
        EKCalendar *calendar = json_get_calendar(r, Param1);
        
        if(calendar)
        {
            NSDate *startDate = [NSDate dateWithTimeIntervalSinceNow:-60 * 60 * 24 * 1000];
            NSDate *endDate = [NSDate dateWithTimeIntervalSinceNow:60 * 60 * 24 * 1000];
            
            NSPredicate *predicate = [defaultCalendarStore predicateForEventsWithStartDate:startDate
              endDate:endDate
            calendars:@[calendar]];
            
            if(predicate)
            {
                NSArray *events = [defaultCalendarStore eventsMatchingPredicate:predicate];
                
                for(unsigned int j = 0; j < [events count]; ++j)
                {
                    EKEvent *event = [events objectAtIndex:j];
                    
                    Json::Value e = Json::Value(Json::objectValue);
                    json_set_event(e, event);
                    ee.append(e);
                }
            }
        }
        
        [defaultCalendarStore release];
    }
    
    Json::StreamWriterBuilder writer;
    writer["indentation"] = "";
    
    C_TEXT t;
    std::string json = Json::writeString(writer, ee);
    Param2.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());
    
    Param2.toParamAtIndex(pParams, 2);
}

void Get_appointment(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
 
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    Json::Value r = Json::Value(Json::objectValue);
    
    EKEventStore *defaultCalendarStore = json_get_calendar_store(r);
    
    if(defaultCalendarStore)
    {
        EKEvent *event = json_get_event(r, Param1);
        
        if(event)
        {
            Json::Value e = Json::Value(Json::objectValue);
            json_set_event(e, event);
            
            Json::StreamWriterBuilder writer;
            writer["indentation"] = "";
            
            C_TEXT t;
            std::string json = Json::writeString(writer, e);
            returnValue.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());
        }
        
        [defaultCalendarStore release];
    }
    
    Json::StreamWriterBuilder writer;
    writer["indentation"] = "";
    
    C_TEXT t;
    std::string json = Json::writeString(writer, r);
    Param2.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());
    
    Param2.toParamAtIndex(pParams, 2);
    returnValue.setReturn(pResult);
}

void UPDATE_APPOINTMENT(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    Json::Value r = Json::Value(Json::objectValue);
    
    Json::Value root;
    Json::CharReaderBuilder builder;
    std::string errors;
    
    CUTF8String Param2_u8;
    Param2.copyUTF8String(&Param2_u8);
    
    Json::CharReader *reader = builder.newCharReader();
    bool parse = reader->parse((const char *)Param2_u8.c_str(),
                               (const char *)Param2_u8.c_str() + Param2_u8.size(),
                               &root,
                               &errors);
    delete reader;
    
    if(parse)
    {
        if(root)
        {
            Json::Value e;
            
            if(root.isArray()){
                
                if(root.size()){
                    
                    e = root[0];
                }
                
            }
            
            if(root.isObject()){
                
                e = root;
                
            }
            
            EKEventStore *defaultCalendarStore = json_get_calendar_store(r);
            
            if(defaultCalendarStore){
                
                @autoreleasepool
                {
                    EKEvent *event = json_get_event(r, Param1);
                    
                    if(event)
                    {
                        if(e["location"].isString()){
                            event.location = [NSString stringWithUTF8String:e["location"].asString().c_str()];
                        }
                        
                        if(e["notes"].isString()){
                            event.notes = [NSString stringWithUTF8String:e["notes"].asString().c_str()];
                        }
                        
                        if(e["title"].isString()){
                            event.title = [NSString stringWithUTF8String:e["title"].asString().c_str()];
                        }
                        
                        if(e["url"].isString()){
                            event.URL = [NSURL URLWithString:[NSString stringWithUTF8String:e["url"].asString().c_str()]];
                        }
                        
                        if(e["startDate"].isString()){
                            
                            NSString *s = [NSString stringWithUTF8String:e["startDate"].asString().c_str()];
                            if([s hasSuffix:@"Z"])
                            {
                                event.startDate = [DateFormatter::GMT dateFromString:s];
                            }else
                            {
                                event.startDate = [DateFormatter::ISO dateFromString:s];
                            }
                        }
                       
                        if(e["endDate"].isString()){
                            
                            NSString *s = [NSString stringWithUTF8String:e["endDate"].asString().c_str()];
                            if([s hasSuffix:@"Z"])
                            {
                                event.endDate = [DateFormatter::GMT dateFromString:s];
                            }else
                            {
                                event.endDate = [DateFormatter::ISO dateFromString:s];
                            }
                        }
                        
                        NSError *error = nil;
                        
                        if(![defaultCalendarStore saveEvent:event span:EKSpanThisEvent  commit:YES error:&error])
                        {
                            r["saveEvent"] = "save failed";
                            r["saveEventErrorDescription"] = [[error description]UTF8String];
                            
                        }else{
                            r["saveEvent"] = "OK";
                            json_set_event(e, event);
                            
                        }
                    }
                }
                
                Json::StreamWriterBuilder writer;
                writer["indentation"] = "";
                
                C_TEXT t;
                std::string json = Json::writeString(writer, e);
                Param2.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());
                
                [defaultCalendarStore release];
            }
        }
    }

    Json::StreamWriterBuilder writer;
    writer["indentation"] = "";
    
    C_TEXT t;
    std::string json = Json::writeString(writer, r);
    Param3.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());
    
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
}

void DELETE_APPOINTMENT(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    Json::Value r = Json::Value(Json::objectValue);
    
    EKEventStore *defaultCalendarStore = json_get_calendar_store(r);
    
    if(defaultCalendarStore)
    {
        EKEvent *event = json_get_event(r, Param1);
        
        if(event)
        {
            NSError *error = nil;
            
            if(![defaultCalendarStore removeEvent:event span:EKSpanThisEvent error:&error])
            {
                r["removeEvent"] = "remove failed";
                r["removeEventErrorDescription"] = [[error description]UTF8String];
            }else
            {
                r["removeEvent"] = "OK";
            }
        }
        [defaultCalendarStore release];
    }

    Json::StreamWriterBuilder writer;
    writer["indentation"] = "";
    
    C_TEXT t;
    std::string json = Json::writeString(writer, r);
    Param2.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());
    
    Param2.toParamAtIndex(pParams, 2);
}

void ON_APPOINTMENT_CALL(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param2.getUTF16StringPtr());
    
    if(methodId)
    {
        CUTF8String path;
        if(json_get_calendarPath(Param1, path))
        {
            CalendarWatch::addToWatch(path, methodId);
        }
    }
}

void CREATE_APPOINTMENT(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    Json::Value r = Json::Value(Json::objectValue);
    
    Json::Value root;
    Json::CharReaderBuilder builder;
    std::string errors;
    
    CUTF8String Param2_u8;
    Param2.copyUTF8String(&Param2_u8);
    
    Json::CharReader *reader = builder.newCharReader();
    bool parse = reader->parse((const char *)Param2_u8.c_str(),
                               (const char *)Param2_u8.c_str() + Param2_u8.size(),
                               &root,
                               &errors);
    delete reader;
    
    if(parse)
    {
        if(root)
        {
            Json::Value e;
            
            if(root.isArray()){
                
                if(root.size()){
                    
                    e = root[0];
                }
                
            }
            
            if(root.isObject()){
                
                e = root;
                
            }
            
            EKEventStore *defaultCalendarStore = json_get_calendar_store(r);
            
            if(defaultCalendarStore){
                
                EKCalendar *calendar = json_get_calendar(r, Param1);
                
                if(calendar)
                {
                    @autoreleasepool
                    {
                        EKEvent  *event = [EKEvent eventWithEventStore:defaultCalendarStore];

                        event.calendar = calendar;
                        
                        if(e["location"].isString()){
                            event.location = [NSString stringWithUTF8String:e["location"].asString().c_str()];
                        }
                       
                        if(e["notes"].isString()){
                            event.notes = [NSString stringWithUTF8String:e["notes"].asString().c_str()];
                        }
                        
                        if(e["title"].isString()){
                            event.title = [NSString stringWithUTF8String:e["title"].asString().c_str()];
                        }
                        
                        if(e["url"].isString()){
                            event.URL = [NSURL URLWithString:[NSString stringWithUTF8String:e["url"].asString().c_str()]];
                        }

                        if(e["startDate"].isString()){
                            
                            NSString *s = [NSString stringWithUTF8String:e["startDate"].asString().c_str()];
                            if([s hasSuffix:@"Z"])
                            {
                                event.startDate = [DateFormatter::GMT dateFromString:s];
                            }else
                            {
                                event.startDate = [DateFormatter::ISO dateFromString:s];
                            }
                        }

                        if(e["endDate"].isString()){
                            
                            NSString *s = [NSString stringWithUTF8String:e["endDate"].asString().c_str()];
                            if([s hasSuffix:@"Z"])
                            {
                                event.endDate = [DateFormatter::GMT dateFromString:s];
                            }else
                            {
                                event.endDate = [DateFormatter::ISO dateFromString:s];
                            }
                        }

                        NSError *error = nil;
                        
                        if(![defaultCalendarStore saveEvent:event span:EKSpanThisEvent  commit:YES error:&error])
                        {
                            r["saveEvent"] = "save failed";
                            r["saveEventErrorDescription"] = [[error description]UTF8String];
                            
                        }else{
                            r["saveEvent"] = "OK";
                            json_set_event(e, event);
                            
                        }
                    }
                }
                
                [defaultCalendarStore release];
            }
            
            Json::StreamWriterBuilder writer;
            writer["indentation"] = "";
            
            C_TEXT t;
            std::string json = Json::writeString(writer, e);
            Param2.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());

        }
    }
    
    Json::StreamWriterBuilder writer;
    writer["indentation"] = "";
    
    C_TEXT t;
    std::string json = Json::writeString(writer, r);
    Param3.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());
    
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
}

void APPOINTMENT_NAMES(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;

    ARRAY_TEXT Param1;
    ARRAY_TEXT Param2;
        
    //no err object
    
    EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
    
    if(defaultCalendarStore)
    {
        Param1.setSize(1);
        Param2.setSize(1);
        
        NSArray *calendars = [defaultCalendarStore calendarsForEntityType:EKEntityTypeEvent];
        for(NSUInteger i = 0; i < [calendars count]; ++i)
        {
            EKCalendar *c = [calendars objectAtIndex:i];
            Param1.appendUTF16String([c title]);
            Param2.appendUTF16String([c calendarIdentifier]);
        }
        
        [defaultCalendarStore release];
    }
    
    Param1.toParamAtIndex(pParams, 1);
    Param2.toParamAtIndex(pParams, 2);
    
}
