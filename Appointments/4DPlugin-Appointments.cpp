/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Appointments.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Appointments
 #	author : miyako
 #	2020/09/06
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Appointments.h"

bool request_permission_granted_for_events = false;

request_permission_t requestPermission(){
    
    if (@available(macOS 10.9, *)) {
    
        switch ([EKEventStore authorizationStatusForEntityType:EKEntityTypeEvent])
        {
            case EKAuthorizationStatusNotDetermined:
            {
                EKEventStore *store = [EKEventStore new];
                [store requestAccessToEntityType:EKEntityTypeEvent completion:^(BOOL granted, NSError * _Nullable error) {
                    if (granted) {
                        request_permission_granted_for_events = true;
                    }
                }];
                return request_permission_not_determined;
                break;
            }
            break;
            case EKAuthorizationStatusRestricted:
                request_permission_granted_for_events = false;
            return request_permission_restricted;
            break;
            case EKAuthorizationStatusDenied:
                request_permission_granted_for_events = false;
            return request_permission_denied;
            break;
            case EKAuthorizationStatusAuthorized:
                request_permission_granted_for_events = true;
                break;
            return request_permission_authorized;
            break;
        }
    }
    return request_permission_unknown;
}

namespace DateFormatter
{
    NSDateFormatter *ISO;
    NSDateFormatter *GMT;
}

namespace CalendarWatch
{
    
    class UserInfo
    {
    private:
        
        notification_t _notification;
        CUTF8String _uid;
        method_id_t _method;
        
    public:
        
        UserInfo(notification_t notification, NSString *event_uid, method_id_t method);
        
        void get(notification_t *notification, CUTF16String &event, method_id_t *method);
        
        ~UserInfo();
    };
    
    UserInfo::UserInfo(notification_t notification, NSString *event_uid, method_id_t method)
    {
        this->_notification = notification;
        if(event_uid)
        {
            this->_uid = CUTF8String((const uint8_t *)[event_uid UTF8String]);
        }
        this->_method = method;
    }
    
    void UserInfo::get(notification_t *notification, CUTF16String &event, method_id_t *method)
    {
        *notification = this->_notification;
        
        *method = this->_method;
        
        C_TEXT t;
        t.setUTF8String(&this->_uid);
        t.copyUTF16String(&event);
    }
    
    UserInfo::~UserInfo()
    {
        
    }
    
    const process_stack_size_t stachSize = 0;
    const process_name_t processName = (PA_Unichar *)"$\0C\0A\0L\0E\0N\0D\0A\0R\0_\0W\0A\0T\0C\0H\0\0\0";
    
    std::map<CUTF8String, method_id_t> paths;
    std::vector<UserInfo> notifications;
    
    FSEventStreamRef eventStream = 0;
    NSTimeInterval latency = 1.0;
    process_number_t monitorProcessId = 0;
    bool processShouldTerminate = false;
    
    method_id_t getMethodId(NSString *path_ns)
    {
        NSString *monitorPath_ns = [path_ns stringByDeletingLastPathComponent];
        CUTF8String monitorPath = CUTF8String((const uint8_t *)[monitorPath_ns UTF8String]);
        monitorPath += (const uint8_t *)"/";
        //global variables: CalendarWatch::paths
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            auto i = paths.find(monitorPath);
            if (i != paths.end())
            {
                return i->second;
            }
            [l unlock];
        }
        [l release];
        
        return 0;
    }
    
    void gotEvent(FSEventStreamRef stream,
                                void *callbackInfo,
                                size_t numEvents,
                                void *eventPaths,
                                const FSEventStreamEventFlags eventFlags[],
                                const FSEventStreamEventId eventIds[]
                                )
    {
        //global variables: CalendarWatch::notifications
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            NSArray *paths_ns = (NSArray *)eventPaths;
            NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"([:HexDigit:]{8}-[:HexDigit:]{4}-[:HexDigit:]{4}-[:HexDigit:]{4}-[:HexDigit:]{12})\\.ics$"
                                                                                   options:NSRegularExpressionCaseInsensitive
                                                                                     error:nil];
            if(regex)
            {
                for(NSUInteger i = 0; i < numEvents; ++i)
                {
                    NSString *path_ns = [paths_ns objectAtIndex:i];
                    
                    NSArray *matches = [regex matchesInString:path_ns
                                                      options:0
                                                        range:NSMakeRange(0, [path_ns length])];
                    
                    for (NSTextCheckingResult *match in matches)
                    {
                        NSString *event_uid = [path_ns substringWithRange:[match rangeAtIndex:1]];
                        FSEventStreamEventFlags flags = eventFlags[i];
                        method_id_t methodId = getMethodId(path_ns);
                        //                            NSLog(@"flags:%d", (unsigned int)flags);
                        if(methodId)
                        {
                            if((flags & kFSEventStreamEventFlagItemRemoved) == kFSEventStreamEventFlagItemRemoved)
                            {
                                //                                    NSLog(@"removed calendar item:\t%@", event_uid);
                                UserInfo userInfo(notification_delete, event_uid, methodId);
                                notifications.push_back(userInfo);
                            }
                            else if((flags & kFSEventStreamEventFlagItemCreated) == kFSEventStreamEventFlagItemCreated)
                            {
                                //                                    NSLog(@"created calendar item:\t%@", event_uid);
                                UserInfo userInfo(notification_create, event_uid, methodId);
                                notifications.push_back(userInfo);
                            }
                            else
                            {
                                //                                    NSLog(@"modified calendar item:\t%@", event_uid);
                                UserInfo userInfo(notification_update, event_uid, methodId);
                                notifications.push_back(userInfo);
                            }
                        }
                    }
                }
            }
            
            listenerLoopExecute();
            [l unlock];
        }
        [l release];
    }
    
    void endMonitor()
    {
        //global variables: CalendarWatch::eventStream
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            if(eventStream)
            {
                FSEventStreamStop(eventStream);
                FSEventStreamUnscheduleFromRunLoop (eventStream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
                FSEventStreamInvalidate(eventStream);
                FSEventStreamRelease(eventStream);
                eventStream = 0;
//                NSLog(@"stop monitoring paths");
            }
            [l unlock];
        }
        [l release];
    }
    
    void startMonitor()
    {
        FSEventStreamContext context = {0, NULL, NULL, NULL, NULL};
        
        NSMutableArray *paths_ns = [[NSMutableArray alloc]init];
        //global variables: CalendarWatch::paths
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            for(std::map<CUTF8String, method_id_t>::iterator it = CalendarWatch::paths.begin(); it != CalendarWatch::paths.end(); it++)
            {
                CUTF8String path = it->first;
                NSString *path_ns = [[NSString alloc]initWithUTF8String:(const char *)path.c_str()];
                if(path_ns)
                {
                    [paths_ns addObject:path_ns];
                    [path_ns release];
                }
            }
            [l unlock];
        }
        
        endMonitor();
        
        listenerLoopStart();
        
        if([paths_ns count])
        {
            if ([l tryLock])
            {
                eventStream = FSEventStreamCreate(NULL,
                                                                                    (FSEventStreamCallback)gotEvent,
                                                                                    &context,
                                                                                    (CFArrayRef)paths_ns,
                                                                                    kFSEventStreamEventIdSinceNow,
                                                                                    (CFAbsoluteTime)latency,
                                                                                    kFSEventStreamCreateFlagUseCFTypes
                                                                                    | kFSEventStreamCreateFlagFileEvents
                                                                                    | kFSEventStreamCreateFlagNoDefer
                                                                                    | kFSEventStreamCreateFlagIgnoreSelf
                                                                                    );
//                NSLog(@"start monitoring paths:%@", [paths_ns description]);
                FSEventStreamScheduleWithRunLoop(eventStream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
                FSEventStreamStart(eventStream);
                
                [l unlock];
            }
            [l release];
            
        }
        [paths_ns release];
    }
    
    bool isInWatch(CUTF8String &path)
    {
        bool inWatch = false;
        
        NSLock *l = [[NSLock alloc]init];
        
        if ([l tryLock])
        {
            auto i = paths.find(path);
            inWatch = (i != paths.end());
            [l unlock];
        }
        
        [l release];
        
        return inWatch;
    }
    
    void addToWatch(CUTF8String &path, method_id_t methodId)
    {
        if (!isInWatch(path))
        {
            NSLock *l = [[NSLock alloc]init];
            if ([l tryLock])
            {
                paths.insert(std::map<CUTF8String, method_id_t>::value_type(path, methodId));
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)startMonitor, NULL);
                [l unlock];
            }
            [l release];
        }
    }
    
    void removeFromWatch(CUTF8String &path)
    {
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            paths.erase(path);
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)startMonitor, NULL);
            if(!paths.size())
            {
                listenerLoopFinish();
            }
            [l unlock];
        }
        [l release];
    }
    
    void removeAllFromWatch()
    {
        NSLock *l = [[NSLock alloc]init];
        if ([l tryLock])
        {
            paths.clear();
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)endMonitor, NULL);
            listenerLoopFinish();
            [l unlock];
        }
        [l release];
    }
    
}

void onStartup()
{
    DateFormatter::GMT = [[NSDateFormatter alloc]init];
    [DateFormatter::GMT setDateFormat:DATE_FORMAT_ISO_GMT];
    [DateFormatter::GMT setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
    
    DateFormatter::ISO = [[NSDateFormatter alloc]init];
    [DateFormatter::ISO setDateFormat:DATE_FORMAT_ISO];
    [DateFormatter::ISO setTimeZone:[NSTimeZone localTimeZone]];
    
    requestPermission();
}

bool isProcessOnExit()
{
    PA_long32 state, time;
    
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    PA_Variable name = PA_GetProcessInfo_s(currentProcessNumber, &state, &time);
    PA_Unistring u = PA_GetStringVariable(name);
    CUTF16String procName(u.fString, u.fLength);
    PA_Unichar _exitProcName[] = {'$', 'x', 'x', 0};
    CUTF16String exitProcName((PA_Unichar *)_exitProcName);
    bool isProcessOnExit = (!procName.compare(exitProcName));
    PA_ClearVariable(&name);
    
    return isProcessOnExit;
}

void onCloseProcess()
{
    if(isProcessOnExit())
    {
        CalendarWatch::removeAllFromWatch();
        [DateFormatter::GMT release];
        [DateFormatter::ISO release];
    }
}

const char *sql_get_calendar_group_uid = "SELECT\n\
ZUID\n\
FROM ZNODE\n\
WHERE Z_PK ==\n\
(\n\
SELECT ZGROUP\n\
FROM  ZNODE\n\
WHERE ZUID == ?\n\
LIMIT 1\n\
);";

const char *sql_get_calendars = "SELECT\n\
ZUID, ZTITLE\n\
FROM ZNODE\n\
WHERE ZISTASKCONTAINER != 1\n\
AND ZGROUP != '';";

void sqlite3_get_calendar_group_uid(NSString *userCalendarPath,
                                                                        CUTF8String &calendar_uid,
                                                                        CUTF8String &group_uid)
{
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        sqlite3 *sqlite3_calendar = NULL;
        
        int err = sqlite3_open([userCalendarPath UTF8String], &sqlite3_calendar);
        
        if(err != SQLITE_OK)
        {
//            NSLog(@"failed to open sqlite database at:%@", userCalendarPath);
        }else
        {
            sqlite3_stmt *sql = NULL;
            err = sqlite3_prepare_v2(sqlite3_calendar, sql_get_calendar_group_uid, 1024, &sql, NULL);
            if(err != SQLITE_OK)
            {
//                NSLog(@"failed to prepare sqlite statement");
            }else
            {
                sqlite3_bind_text(sql, 1, (const char *)calendar_uid.c_str(), calendar_uid.length(), NULL);
                
                while(SQLITE_ROW == (err = sqlite3_step(sql)))
                {
                    const unsigned char *_group_uid = sqlite3_column_text(sql, 0);
                    if(_group_uid)
                    {
                        group_uid = CUTF8String(_group_uid, strlen((const char *)_group_uid));
                    }
                }
                sqlite3_finalize(sql);
            }
            sqlite3_close(sqlite3_calendar);
        }
        [l unlock];
    }
    [l release];
}

void sqlite3_get_calendars(NSString *userCalendarPath,
                                                     ARRAY_TEXT &uids,
                                                     ARRAY_TEXT &titles)
{
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        sqlite3 *sqlite3_calendar = NULL;
        
        int err = sqlite3_open([userCalendarPath UTF8String], &sqlite3_calendar);
        
        if(err != SQLITE_OK)
        {
//            NSLog(@"failed to open sqlite database at:%@", userCalendarPath);
        }else
        {
            sqlite3_stmt *sql = NULL;
            err = sqlite3_prepare_v2(sqlite3_calendar, sql_get_calendars, 1024, &sql, NULL);
            if(err != SQLITE_OK)
            {
//                NSLog(@"failed to prepare sqlite statement");
            }else
            {
                while(SQLITE_ROW == (err = sqlite3_step(sql)))
                {
                    const unsigned char *_calendar_uid = sqlite3_column_text(sql, 0);
                    const unsigned char *_title = sqlite3_column_text(sql, 1);
                    
                    if(_calendar_uid)
                    {
                        if(_title)
                        {
                            uids.appendUTF8String(_calendar_uid, strlen((const char *)_calendar_uid));
                            titles.appendUTF8String(_title, strlen((const char *)_title));
                        }
                        
                    }
                }
                sqlite3_finalize(sql);
            }
            sqlite3_close(sqlite3_calendar);
        }
        [l unlock];
    }
    [l release];
}

#pragma mark -

void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
    CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
    NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
    returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

#pragma mark -

void listenerLoop()
{
    CalendarWatch::monitorProcessId = PA_GetCurrentProcessNumber();
//    NSLog(@"%@", @"listenerLoop:start");
    
    NSLock *l = [[NSLock alloc]init];
    
    while((!CalendarWatch::processShouldTerminate) && !PA_IsProcessDying())
    {
        PA_FreezeProcess(PA_GetCurrentProcessNumber());
        PA_YieldAbsolute();
        
        //global variables: CalendarWatch::notifications,processShouldTerminate
        if ([l tryLock])
        {
            if(!CalendarWatch::processShouldTerminate)
            {
                if(CalendarWatch::notifications.size())
                {
                    C_TEXT processName;
                    generateUuid(processName);
                    PA_NewProcess((void *)listenerLoopExecuteMethod,
                                                CalendarWatch::stachSize,
                                                (PA_Unichar *)processName.getUTF16StringPtr());
                }
            }
            [l unlock];
        }
    }//while(!CalendarWatch::processShouldTerminate)
    CalendarWatch::monitorProcessId = 0;
    
    PA_KillProcess();
//    NSLog(@"%@", @"listenerLoop:end");
    [l release];
}

void listenerLoopStart()
{
    //global variables: CalendarWatch::monitorProcessId,processShouldTerminate
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        if(!CalendarWatch::monitorProcessId)
        {
            CalendarWatch::processShouldTerminate = false;
            PA_NewProcess((void *)listenerLoop,
                                        CalendarWatch::stachSize,
                                        CalendarWatch::processName);
        }
        [l unlock];
    }
    [l release];
}

void listenerLoopFinish()
{
    //global variables: CalendarWatch::monitorProcessId,processShouldTerminate
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        CalendarWatch::processShouldTerminate = true;
        PA_UnfreezeProcess(CalendarWatch::monitorProcessId);
        [l unlock];
    }
    [l release];
}

void listenerLoopExecute()
{
    //global variables: CalendarWatch::monitorProcessId,processShouldTerminate
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        CalendarWatch::processShouldTerminate = false;
        PA_UnfreezeProcess(CalendarWatch::monitorProcessId);
        [l unlock];
    }
    [l release];
}

#pragma mark CalendarStore

EKEventStore *json_get_calendar_store(PA_ObjectRef obj)
{
    EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
        
    if(defaultCalendarStore)
    {
        ob_set_s(obj, L"json_get_calendar_store", "OK");

    }else{
        
        ob_set_s(obj, L"json_get_calendar_store", "calendar access denied");
    }

    return defaultCalendarStore;
}

EKCalendar *json_get_calendar(PA_ObjectRef obj, C_TEXT& Param1)
{
    EKCalendar *calendar = nil;
   
    EKEventStore *defaultCalendarStore = json_get_calendar_store(obj);
    
    if(defaultCalendarStore)
    {        
        NSString *calendarName = Param1.copyUTF16String();
        NSArray *calendars = [defaultCalendarStore calendarsForEntityType:EKEntityTypeEvent];
        for(NSUInteger i = 0; i < [calendars count]; ++i)
        {
            EKCalendar *c = [calendars objectAtIndex:i];
            
            if(([[c title]caseInsensitiveCompare:calendarName] == NSOrderedSame)
               && c.type == EKCalendarTypeCalDAV)
            {
                calendar = c;
                break;
            }
        }
    }
    
    if(calendar)
    {
        ob_set_s(obj, L"json_get_calendar", "OK");
        
    }else{
        
        ob_set_s(obj, L"json_get_calendar", "calendar not found");
        
    }
    
    return calendar;
}

EKEvent *json_get_event(EKEventStore *defaultCalendarStore, PA_ObjectRef obj, NSString *uid)
{
    EKEvent *event = nil;
    
    NSArray *events = [defaultCalendarStore calendarItemsWithExternalIdentifier:uid];
    if([events count]) {
        event = [events objectAtIndex:0];
    }
        
    if(event)
    {
        ob_set_s(obj, "json_get_event", "OK");
    }else{
        ob_set_s(obj, "json_get_event", "event not found");
    }
    
    return event;
}

void json_set_event(Json::Value& obj, EKEvent *event)
{
    
    obj["location"] = event.location ? [event.location UTF8String] : Json::Value(Json::nullValue);
    obj["notes"] = event.notes ? [event.notes UTF8String] : Json::Value(Json::nullValue);
    obj["title"] = event.title ? [event.title UTF8String] : Json::Value(Json::nullValue);
    obj["url"] = event.URL ? [[event.URL absoluteString]UTF8String] : Json::Value(Json::nullValue);
    obj["uid"] = event.calendarItemExternalIdentifier ? [event.calendarItemExternalIdentifier UTF8String] : Json::Value(Json::nullValue);

    obj["endDate"] = event.endDate ? [[DateFormatter::GMT stringFromDate:event.endDate]UTF8String] : Json::Value(Json::nullValue);
    
    obj["startDate"] = event.startDate ? [[DateFormatter::GMT stringFromDate:event.startDate ]UTF8String] : Json::Value(Json::nullValue);
    
    
    obj["dateStamp"] = event.lastModifiedDate ? [[DateFormatter::GMT stringFromDate:event.lastModifiedDate]UTF8String] : Json::Value(Json::nullValue);

    if(event.endDate){
        
        NSString *localDateString = [DateFormatter::ISO stringFromDate:event.endDate];
        int hour = (int)[[localDateString substringWithRange:NSMakeRange(11,2)]integerValue];
        int minute = (int)[[localDateString substringWithRange:NSMakeRange(14,2)]integerValue];
        int second = (int)[[localDateString substringWithRange:NSMakeRange(17,2)]integerValue];
        obj["endDateTime"] = (second + (minute * 60) + (hour * 3600)) * 1000;

    }
    
    if(event.startDate){
        
        NSString *localDateString = [DateFormatter::ISO stringFromDate:event.startDate];
        int hour = (int)[[localDateString substringWithRange:NSMakeRange(11,2)]integerValue];
        int minute = (int)[[localDateString substringWithRange:NSMakeRange(14,2)]integerValue];
        int second = (int)[[localDateString substringWithRange:NSMakeRange(17,2)]integerValue];
        obj["startDateTime"] = (second + (minute * 60) + (hour * 3600)) * 1000;

    }
    
    if(event.lastModifiedDate){
        
        NSString *localDateString = [DateFormatter::ISO stringFromDate:event.lastModifiedDate];
        
        int hour = (int)[[localDateString substringWithRange:NSMakeRange(11,2)]integerValue];
        int minute = (int)[[localDateString substringWithRange:NSMakeRange(14,2)]integerValue];
        int second = (int)[[localDateString substringWithRange:NSMakeRange(17,2)]integerValue];
        obj["dateStampTime"] = (second + (minute * 60) + (hour * 3600)) * 1000;

    }
        
    obj["calendarName"] = [event.calendar.title UTF8String];

    if(([event startDate]) && ([event endDate]))
    {
        obj["duration"] = [[event endDate] timeIntervalSinceDate:[event startDate]];
    }
    
}

bool json_get_calendarPath(C_TEXT &Param1, CUTF8String &path)
{
    bool success = NO;
    
    NSString *userCalendarPath = [NSString stringWithFormat:@"%@/Calendars/",
                                                                [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)
                                                                 objectAtIndex:0]];
    ARRAY_TEXT out_uids;
    ARRAY_TEXT out_titles;
    
    NSString *titleToSearch = Param1.copyUTF16String();
    
    sqlite3_get_calendars([NSString stringWithFormat:@"%@Calendar Cache", userCalendarPath], out_uids, out_titles);
    
    NSUInteger size = out_uids.getSize();
    
    for(NSUInteger i = 0; i < size; ++i)
    {
        NSString *title = out_titles.copyUTF16StringAtIndex(i);
        
        if([title isEqualToString:titleToSearch])
        {
            CUTF8String calendar_uid, group_uid;
            out_uids.copyUTF8StringAtIndex(&calendar_uid, i);
            
            sqlite3_get_calendar_group_uid([NSString stringWithFormat:@"%@Calendar Cache", userCalendarPath], calendar_uid, group_uid);
            
            NSFileManager *defaultManager = [[NSFileManager alloc]init];
            
            NSString *path_caldav = [NSString stringWithFormat:@"%@%s%s/%s%s", userCalendarPath, group_uid.c_str(), ".caldav", calendar_uid.c_str(), ".calendar"];
            NSString *path_exchange = [NSString stringWithFormat:@"%@%s%s/%s%s", userCalendarPath, group_uid.c_str(), ".exchange", calendar_uid.c_str(), ".calendar"];
            
            BOOL isDirectory;
            C_TEXT temp;
            
            if(([defaultManager fileExistsAtPath:path_caldav isDirectory:&isDirectory]) && isDirectory)
            {
                temp.setUTF16String([NSString stringWithFormat:@"%@/Events/", path_caldav]);
                temp.copyUTF8String(&path);
                success = YES;
            }
            else if(([defaultManager fileExistsAtPath:path_exchange isDirectory:&isDirectory]) && isDirectory)
            {
                temp.setUTF16String([NSString stringWithFormat:@"%@/Events/", path_exchange]);
                temp.copyUTF8String(&path);
                success = YES;
            }
            [defaultManager release];
        }
        
        [title release];
        
        if(success) break;
    }
    
    [titleToSearch release];
    
    return success;
}

void event_to_json(CUTF16String *eventId, CUTF16String *eventJson)
{
    NSString *Param1 = [[NSString alloc]initWithCharacters:(const unichar *)eventJson->c_str() length:eventJson->length()];
    
    PA_ObjectRef r = PA_CreateObject();
    
    EKEventStore *defaultCalendarStore = [[EKEventStore alloc]init];
    EKEvent *event = json_get_event(defaultCalendarStore, r, Param1);
    [defaultCalendarStore release];
    
    [Param1 release];
    
    PA_DisposeObject(r);
    
    if(event)
    {
        Json::Value ee = Json::Value(Json::arrayValue);
        Json::Value e = Json::Value(Json::objectValue);
        
        json_set_event(e, event);
        
        ee.append(e);
        
        Json::StreamWriterBuilder writer;
        writer["indentation"] = "";
        
        C_TEXT t;
        std::string json = Json::writeString(writer, ee);
        t.setUTF8String((const uint8_t *)json.c_str(), (uint32_t)json.length());
        
        t.copyUTF16String(eventJson);
    }
    
}

void listenerLoopExecuteMethod()
{
    //global variables: CalendarWatch::notifications
    NSLock *l = [[NSLock alloc]init];
    if ([l tryLock])
    {
        if(CalendarWatch::notifications.size())
        {
            std::vector<CalendarWatch::UserInfo>::iterator it = CalendarWatch::notifications.begin();
            
            CalendarWatch::UserInfo userInfo = *it;
            
            notification_t notification;
            CUTF16String eventId;
            method_id_t methodId;
            
            userInfo.get(&notification, eventId, &methodId);
            
            PA_Variable    params[3];

            params[0] = PA_CreateVariable(eVK_Longint);
            params[1] = PA_CreateVariable(eVK_Unistring);
            params[2] = PA_CreateVariable(eVK_Unistring);

            PA_SetLongintVariable(&params[0], notification);
            
            PA_Unistring event = PA_CreateUnistring((PA_Unichar *)eventId.c_str());
            PA_SetStringVariable(&params[1], &event);

            //eventId to JSON
            CUTF16String eventJson;
            event_to_json(&eventId, &eventJson);
            PA_Unistring eventInfo = PA_CreateUnistring((PA_Unichar *)eventJson.c_str());
            PA_SetStringVariable(&params[2], &eventInfo);
            
            CalendarWatch::notifications.erase(it);
            
            PA_ExecuteMethodByID(methodId, params, 3);
            
            PA_ClearVariable(&params[0]);
            PA_ClearVariable(&params[1]);
            PA_ClearVariable(&params[2]);
        }
        [l unlock];
    }
    [l release];
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
                case kInitPlugin :
                case kServerInitPlugin :
                    onStartup();
                    break;
                    
                case kCloseProcess :
                    onCloseProcess();
                    break;
                
			// --- Appointments
            
			case 1 :
				ALL_APPOINTMENTS(params);
				break;
			case 2 :
				Get_appointment(params);
				break;
			case 3 :
				UPDATE_APPOINTMENT(params);
				break;
			case 4 :
				DELETE_APPOINTMENT(params);
				break;
			case 5 :
				ON_APPOINTMENT_CALL(params);
				break;
			case 6 :
				CREATE_APPOINTMENT(params);
				break;
			case 7 :
				APPOINTMENT_NAMES(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void event_to_object(EKEvent *event, PA_ObjectRef eventObj) {
    
    if(event.location){
        ob_set_s(eventObj, L"location", [event.location UTF8String]);
    }else{
        ob_set_0(eventObj, L"location");
    }
    
    if(event.notes){
        ob_set_s(eventObj, L"notes", [event.notes UTF8String]);
    }else{
        ob_set_0(eventObj, L"notes");
    }

    if(event.title){
        ob_set_s(eventObj, L"title", [event.title UTF8String]);
    }else{
        ob_set_0(eventObj, L"title");
    }
    
    if(event.calendarItemExternalIdentifier){
        ob_set_s(eventObj, L"id", [event.calendarItemExternalIdentifier UTF8String]);
    }else{
        ob_set_0(eventObj, L"id");
    }
    
    if(event.URL){
        ob_set_s(eventObj, L"url", [[event.URL absoluteString]UTF8String]);
    }else{
        ob_set_0(eventObj, L"url");
    }
    
    if(event.startDate){
        ob_set_s(eventObj, L"startDate", [[DateFormatter::GMT stringFromDate:event.startDate]UTF8String]);
    }else{
        ob_set_0(eventObj, L"startDate");
    }
    
    if(event.endDate){
        ob_set_s(eventObj, L"endDate", [[DateFormatter::GMT stringFromDate:event.endDate]UTF8String]);
    }else{
        ob_set_0(eventObj, L"endDate");
    }
    
    if(event.calendar){
        ob_set_s(eventObj, L"calendar", [event.calendar.title UTF8String]);
        ob_set_s(eventObj, L"calendarIdentifier", [event.calendar.calendarIdentifier UTF8String]);
    }else{
        ob_set_0(eventObj, L"calendar");
        ob_set_0(eventObj, L"calendarIdentifier");
    }
    
    if((event.startDate) && (event.endDate)){
        ob_set_n(eventObj, L"duration", [event.endDate timeIntervalSinceDate:event.startDate]);
    }else{
        ob_set_0(eventObj, L"duration");
    }

}

void ALL_APPOINTMENTS(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    PA_CollectionRef appointments = PA_CreateCollection();
    PA_ObjectRef returnValue = PA_CreateObject();
    
    EKEventStore *defaultCalendarStore = json_get_calendar_store(returnValue);

    if(defaultCalendarStore)
    {
         EKCalendar *calendar = json_get_calendar(returnValue, Param1);
        
        if(calendar)
        {
            NSDate *startDate = [NSDate dateWithTimeIntervalSinceNow:-60 * 60 * 24 * 1000];
            NSDate *endDate = [NSDate dateWithTimeIntervalSinceNow:60 * 60 * 24 * 1000];
            
            NSPredicate *predicate = [defaultCalendarStore predicateForEventsWithStartDate:startDate
              endDate:endDate
            calendars:@[calendar]];
            
            if(predicate)
            {
                NSArray *events = [defaultCalendarStore eventsMatchingPredicate:predicate];
                
                for(unsigned int j = 0; j < [events count]; ++j)
                {
                    EKEvent *event = [events objectAtIndex:j];
                    
                    if(event)
                    {
                        PA_ObjectRef eventObj = PA_CreateObject();
                        event_to_object(event, eventObj);

                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, eventObj);
                        PA_SetCollectionElement(appointments, PA_GetCollectionLength(appointments), v);
                        PA_ClearVariable(&v);

                    }
                }
                
                ob_set_c(returnValue, L"appointments", appointments);
            }
        }
        
        [defaultCalendarStore release];
    }
    
    PA_ReturnObject(params, returnValue);
}

void Get_appointment(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
 
    C_TEXT Param1;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    PA_ObjectRef returnValue = PA_CreateObject();
        
    EKEventStore *defaultCalendarStore = json_get_calendar_store(returnValue);
    
    if(defaultCalendarStore)
    {
        NSString *uid = Param1.copyUTF16String();
        EKEvent *event = json_get_event(defaultCalendarStore, returnValue, uid);
        [uid release];
                
        if(event)
        {
            PA_ObjectRef eventObj = PA_CreateObject();
            event_to_object(event, eventObj);
            ob_set_o(returnValue, L"event", eventObj);
        }
        
        [defaultCalendarStore release];
    }

    
    PA_ReturnObject(params, returnValue);
}

void UPDATE_APPOINTMENT(PA_PluginParameters params) {

    PA_ObjectRef Param1 = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
        
    EKEventStore *defaultCalendarStore = json_get_calendar_store(returnValue);
    
    if(defaultCalendarStore)
    {
      
        if(Param1){
            
            CUTF8String _calendarItemExternalIdentifier;
            if(ob_get_s(Param1, L"id", &_calendarItemExternalIdentifier))
            {
                NSString *uid = [NSString stringWithUTF8String:(const char*)_calendarItemExternalIdentifier.c_str()];
                
                EKEvent *event = json_get_event(defaultCalendarStore, returnValue, uid);
                
                if(event)
                {
                    CUTF8String _location;
                    if(ob_get_s(Param1, L"location", &_location)){
                        event.location = [NSString stringWithUTF8String:(const char *)_location.c_str()];
                    }
                    
                    CUTF8String _notes;
                    if(ob_get_s(Param1, L"notes", &_notes)){
                        event.notes = [NSString stringWithUTF8String:(const char *)_notes.c_str()];
                    }
                    
                    CUTF8String _title;
                    if(ob_get_s(Param1, L"title", &_title)){
                        event.title = [NSString stringWithUTF8String:(const char *)_title.c_str()];
                    }
                    
                    CUTF8String _url;
                    if(ob_get_s(Param1, L"url", &_url)){
                        event.URL = [NSURL URLWithString:[NSString stringWithUTF8String:(const char *)_url.c_str()]];
                    }
                    
                    CUTF8String _startDate;
                    if(ob_get_s(Param1, L"startDate", &_startDate)){
                        NSString *s = [NSString stringWithUTF8String:(const char *)_startDate.c_str()];
                        if([s hasSuffix:@"Z"])
                        {
                            event.startDate = [DateFormatter::GMT dateFromString:s];
                        }else
                        {
                            event.startDate = [DateFormatter::ISO dateFromString:s];
                        }
                    }
                    
                    CUTF8String _endDate;
                    if(ob_get_s(Param1, L"endDate", &_endDate)){
                        NSString *s = [NSString stringWithUTF8String:(const char *)_endDate.c_str()];
                        if([s hasSuffix:@"Z"])
                        {
                            event.endDate = [DateFormatter::GMT dateFromString:s];
                        }else
                        {
                            event.endDate = [DateFormatter::ISO dateFromString:s];
                        }
                    }
                                        
                    NSError *error = nil;
                    
                    if(![defaultCalendarStore saveEvent:event span:EKSpanThisEvent  commit:YES error:&error])
                    {
                        ob_set_s(returnValue, L"saveEvent", "save failed");
                        ob_set_s(returnValue, L"saveEventErrorDescription", [[error description]UTF8String]);
                          
                    }else{
                       ob_set_s(returnValue, L"saveEvent", "OK");
                        
                        PA_ObjectRef eventObj = PA_CreateObject();
                        event_to_object(event, eventObj);
                        ob_set_o(returnValue, L"event", eventObj);
                        
                    }
                }
            }
        }
        
        [defaultCalendarStore release];
    }

    PA_ReturnObject(params, returnValue);
}

void CREATE_APPOINTMENT(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    PA_ObjectRef Param2 = PA_GetObjectParameter(params, 2);
    PA_ObjectRef returnValue = PA_CreateObject();
             
    EKEventStore *defaultCalendarStore = json_get_calendar_store(returnValue);
    
    if(defaultCalendarStore){
        
        EKCalendar *calendar = json_get_calendar(returnValue, Param1);
        
        if(calendar)
        {
            EKEvent *event = [EKEvent eventWithEventStore:defaultCalendarStore];
            
            event.calendar = calendar;
            
            CUTF8String _location;
            if(ob_get_s(Param2, L"location", &_location)){
                event.location = [NSString stringWithUTF8String:(const char *)_location.c_str()];
            }
            
            CUTF8String _notes;
            if(ob_get_s(Param2, L"notes", &_notes)){
                event.notes = [NSString stringWithUTF8String:(const char *)_notes.c_str()];
            }
            
            CUTF8String _title;
            if(ob_get_s(Param2, L"title", &_title)){
                event.title = [NSString stringWithUTF8String:(const char *)_title.c_str()];
            }
            
            CUTF8String _url;
            if(ob_get_s(Param2, L"url", &_url)){
                event.URL = [NSURL URLWithString:[NSString stringWithUTF8String:(const char *)_url.c_str()]];
            }
            
            CUTF8String _startDate;
            if(ob_get_s(Param2, L"startDate", &_startDate)){
                NSString *s = [NSString stringWithUTF8String:(const char *)_startDate.c_str()];
                if([s hasSuffix:@"Z"])
                {
                    event.startDate = [DateFormatter::GMT dateFromString:s];
                }else
                {
                    event.startDate = [DateFormatter::ISO dateFromString:s];
                }
            }
            
            CUTF8String _endDate;
            if(ob_get_s(Param2, L"endDate", &_endDate)){
                NSString *s = [NSString stringWithUTF8String:(const char *)_endDate.c_str()];
                if([s hasSuffix:@"Z"])
                {
                    event.endDate = [DateFormatter::GMT dateFromString:s];
                }else
                {
                    event.endDate = [DateFormatter::ISO dateFromString:s];
                }
            }
            
            NSError *error = nil;
            
            if(![defaultCalendarStore saveEvent:event span:EKSpanThisEvent  commit:YES error:&error])
            {
                ob_set_s(returnValue, L"saveEvent", "save failed");
                ob_set_s(returnValue, L"saveEventErrorDescription", [[error description]UTF8String]);
                
            }else{
                ob_set_s(returnValue, L"saveEvent", "OK");
                
                PA_ObjectRef eventObj = PA_CreateObject();
                event_to_object(event, eventObj);
                ob_set_o(returnValue, L"event", eventObj);
            }
            
        }
        
        [defaultCalendarStore release];
    }

    PA_ReturnObject(params, returnValue);
}

void DELETE_APPOINTMENT(PA_PluginParameters params) {
    
    PA_ObjectRef Param1 = PA_GetObjectParameter(params, 1);
    PA_ObjectRef returnValue = PA_CreateObject();
        
    EKEventStore *defaultCalendarStore = json_get_calendar_store(returnValue);
    
    if(defaultCalendarStore)
    {
      
        if(Param1){
            
            CUTF8String _calendarItemExternalIdentifier;
            if(ob_get_s(Param1, L"id", &_calendarItemExternalIdentifier))
            {
                NSString *uid = [NSString stringWithUTF8String:(const char*)_calendarItemExternalIdentifier.c_str()];
                
                EKEvent *event = json_get_event(defaultCalendarStore, returnValue, uid);
                
                if(event)
                {
                    NSError *error = nil;
                    
                    if(![defaultCalendarStore removeEvent:event span:EKSpanThisEvent error:&error])
                    {
                        ob_set_s(returnValue, L"removeEvent", "remove failed");
                        ob_set_s(returnValue, L"removeEventErrorDescription", [[error description]UTF8String]);
                        
                    }else
                    {
                        ob_set_s(returnValue, L"removeEvent", "OK");
                    }
                }
            }
        }
        
        [defaultCalendarStore release];
    }

    PA_ReturnObject(params, returnValue);
}

void APPOINTMENT_NAMES(PA_PluginParameters params) {

    PA_CollectionRef appointments = PA_CreateCollection();
    
    PA_ObjectRef r = PA_CreateObject();
    EKEventStore *defaultCalendarStore = json_get_calendar_store(r);
    PA_DisposeObject(r);
    
    if(defaultCalendarStore)
    {
        NSArray *calendars = [defaultCalendarStore calendarsForEntityType:EKEntityTypeEvent];
        for(NSUInteger i = 0; i < [calendars count]; ++i)
        {
            EKCalendar *c = [calendars objectAtIndex:i];
            PA_ObjectRef calendar = PA_CreateObject();
            ob_set_s(calendar, L"title", [[c title]UTF8String]);
            ob_set_s(calendar, L"calendarIdentifier", [[c calendarIdentifier]UTF8String]);
            
            PA_Variable v = PA_CreateVariable(eVK_Object);
            PA_SetObjectVariable(&v, calendar);
            PA_SetCollectionElement(appointments, PA_GetCollectionLength(appointments), v);
            PA_ClearVariable(&v);
        }
        
        [defaultCalendarStore release];
    }
    
    PA_ReturnCollection(params, appointments);
}

void ON_APPOINTMENT_CALL(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param2.getUTF16StringPtr());
    
    if(methodId)
    {
        CUTF8String path;
        if(json_get_calendarPath(Param1, path))
        {
            CalendarWatch::addToWatch(path, methodId);
        }
    }
}
